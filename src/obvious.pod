title: Things obvious to others, but not to you

=head1 Coverage

This document describes "special" traps you may encounter when running
your plain CGIs under C<Apache::Registry> and C<Apache::PerlRun>.








=head1 Where do the warnings/errors go?

Your CGI does not work and you want to see what the problem is. The
best idea is to check out any errors that the server may be reporting.
Where I can find these errors?

Generally all errors are logged into an error_log file. The exact file
location and name are defined in the http.conf file.  Look for the
C<ErrorLog> parameter. My httpd.conf says:

  ErrorLog var/logs/error_log

Hey, where is the beginning of the path? There is another Apache
parameter called C<ServerRoot>. Every time apache sees a value of the
parameter with no absolute path (e.g C</tmp/my.txt>) but with relative
path (e.g C<my.txt>) it prepends the value of the C<ServerRoot> to
this value. I have:

  ServerRoot /usr/local/apache

So I will look for error_log file at
C</usr/local/apache/var/logs/error_log>. Of course you can also use an
absolute path to define the file's location at the file system.

<META>: is this 100% correct?

But there are cases when errors don't go to the error_log file. For
example some errors are being printed to the console (tty) you have
executed the httpd from (unless you redirected the httpd's stderr
flow). This happens when the server didn't open the error_log file for
writing yet.

For example, if you have mistakenly entered a non-existent directory
path in your C<ErrorLog> directive, the error message will be printed
on the controlling tty.  Or, if the error happens when server executes
C<PerlRequire> or C<PerlModule> directive you might see the errors
here also.

You are probably wonder where all the errors go when you are running
the server in single mode (C<httpd -X>). They go to the console. That
is because when running in the single mode there is no parent httpd
process to perform all the logging. It includes all the status
messages that generally show up in the error_log file.

</META>

=head1 Setting environment variables for scripts called from CGI.

Perl uses C<sh()> for its iteractions for C<system()> and C<open()>
calls. So when you want to set a temporary variable when you call a
script from your CGI you do:

 open UTIL, "USER=stas ; script.pl | " or die "...: $!\n";

or

  system "USER=stas ; script.pl";

This is useful for example if you need to invoke a script that uses
CGI.pm from within a mod_perl script. We are tricking the perl script
to think it's a simple CGI, which is not running under mod_perl.

  open(PUBLISH, "GATEWAY_INTERFACE=CGI/1.1 ; script.cgi
       \"param1=value1&param2=value2\" |") or die "...: $!\n";

Make sure, that the parameters you pass are shell safe (All "unsafe"
characters like single-tick should be properly escaped).

However you are fork-ing to run a Perl script, so you have thrown the
so hardly gained performance out the window.  Whatever script.cgi is
now, it should be moved to a module with a subroutine you can call
directly from your script, to avoid the fork.




=cut









